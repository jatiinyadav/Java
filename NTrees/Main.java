package NTrees;

public class Main {
    public static void main(String[] args) {
        
        // Binary Tree
        // 1. It is called binary tree because it cannot contain more than 2 values (0, 1)
        // 2. The first Node is called Root node.
  
        // Types of Binary Trees

        // 1. Full Binary Tree
        // Either have 0 or 2 children

        // 2. Complete Binary Tree
        // All levels are completely filled except the last level
        // The last level has all nodes as left as possible

        // 3. Perfect Binary Tree
        // All the leaf nodes are at the same level

        // 4. Balanced Binary Tree
        // The height can be of max log(N) where N is nodes
        // For every Node height(left) - height(right) <= 1

        // 5. Degenerate Binary Tree
        // Every Node has a single children either on the left or right

        // -------------------------------------------------

        // Depth First Search (DFS)

        // 1. Inorder Traversal
        // Left Root Right

        // 2. Preorder Traversal
        // Root Left Right

        // 3. Postorder Traversal
        // Left Right Root

        // Breadth First Search (BFS)
 
        // It goes level wise
        // In a horizontal way

    }
}

// Inorder of a BST is always Sorted
// Left Root Right

// Preorder
// Inorder
// PostOrder
// Level Order

// Same Pattern Recursion
// Maximum Depth
// Balance BT
// Diameter BT

// Maximum Path Sum in BT L17 --x--

// Same Tree  https://leetcode.com/problems/same-tree/

// Zig-Zag Level Order Traversal
// https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/

// Boundary Level Traversal L20 --x--
// Vertical Order Traversal L21 --x--
 
// Top view of a BT
// Bottom view of BT
// Left view of BT
// Right view of BT
 
// Symmetric Binary Tree
// https://leetcode.com/problems/symmetric-tree/

// Root to Node path BT

// Maximum width of BT --x--
// https://leetcode.com/problems/maximum-width-of-binary-tree/

// Children Sum of BT

// All Nodes Distance K in Binary Tree
// https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/

// Lowest Common Ancestor
// https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

// Minimum Time Taken to Burn The BT from node

// Count total nodes in COMPLETE BT
// https://leetcode.com/problems/count-complete-tree-nodes/

// Construct BT from Inorder and Preorder
// https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

// Construct BT from Inorder and Postorder
// https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/

// Serialize and Deserialize BT --x-- L36
// Morris Traversal | Inorder | Postorder

// Flatten a Binary Tree
// https://leetcode.com/problems/flatten-binary-tree-to-linked-list/
// 3rd Approach Morris Traversal



// If a BST is given try to get the Inorder of BST 
// The inorder of BST is always sorted

// Binary Search Tree
// https://leetcode.com/problems/search-in-a-binary-search-tree/

// Ceil in Binary Search Tree

// Floor in Binary Search Tree

// Insert a node in BST
// https://leetcode.com/problems/insert-into-a-binary-search-tree/

// Delete a node in BST
// https://leetcode.com/problems/delete-node-in-a-bst

// Kth Smallest Element in BST
// https://leetcode.com/problems/kth-smallest-element-in-a-bst/

// Validate BST
// https://leetcode.com/problems/validate-binary-search-tree/

// Lowest Common Ancestor in BST
// https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

// Construct BST from Preorder Traversal
// https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/

// Inorder Successor in BST
// https://leetcode.com/problems/inorder-successor-in-bst/

// Design BST Iterator
// https://leetcode.com/problems/binary-search-tree-iterator/

// Two sum 4
// https://leetcode.com/problems/two-sum-iv-input-is-a-bst/

// Recover BST
// https://leetcode.com/problems/recover-binary-search-tree/